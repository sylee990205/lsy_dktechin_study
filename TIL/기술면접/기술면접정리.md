# Tech interview

## Java
<details>


<summary> Java의 특징 </summary>
Java는 객체지향 프로그래밍 언어로 기본 자료형을 제외한 모든 요소들이 객체로 표현됩니다.

- 객체 지향 개념의 특징인 캡슐화, 상속, 다형성이 잘 적용된 언어
- 장점
  - 자바는 자바 프로그램이 실행되는 동안 운영체제를 대신하는 자바 가상 머신 JVM 위에서 동작하기에 운영체제에 독립적이다
    - GabageCollector를 통한 자동적인 메모리 관리 가능
- 단점
  - JVM 위에서 동작한다는 것은 큰 장점이지만 JVM 위에서 동작하기때문에 다른 언어에 비교하여 실행 속도가 느리다는 단점이 있다
  - 다중 상속이나 타입에 엄격하며 제약이 많음

### 꼬리질문
- 방금 말씀하신 객체 지향 개념의 특징을 설명해주세요
  - 캡슐화
    - 객체 내부의 속성이나 행위를 외부에서 직접 접근할 수 없게 하는 것
    - private 멤버변수, getter/setter

  - 상속
    - 자식 클래스에서 부모 클래스로부터 부모의 모든 자원을 물려 받는 것을 의미
    - 상속을 통해 비효율적인 코드 중복을 피할 수 있고, 부모 클래스의 수정을 통해 자식 클래스 전체가 수정되기때문에 유지보수가 편리함
      ### 꼬리질문2
        - 자바는 다중상속을 지원하지않는데 그 이유는? 그리고 인터페이스는 지원하는데 왜 가능?
          - 다중상속의 경우 하나의 클래스가 여러 상위 클래스를 상속받는 것을 말하는데 여러 상위 클래스에 동일한 이름의 메소드가 있을 때 하위 클래스에서 어떤 메소드를 사용해야하는지 알 수 없는 문제가 발생해 자바에서는 다중상속을 지원하지않는것입니다.
          - 인터페이스는 구현체가 없기때문에 가능합니다.
    - 예시: Spring Data JPA를 사용하면 Repository에서 JpaRepository를 상속하여 우리가 직접 기능을 정의하지않아도 CRUD, Paging 등의 기능을 사용할 수 있는 것
  - 추상화
    - 클래스들의 공통적인 요소를 뽑아서 상위 클래스를 만들어내는 것
    - 즉, 공통적인 속성과 기능을 정의함으로써 코드의 중복을 줄이는 것
    - 자바에서의 예시로는 추상클래스와 인터페이스가 있음
  - 다형성
    - 하나의 객체나 메소드가 여러가지 다른 형태를 가질 수 있는 것
    - 오버라이딩과 오버로딩이 그 예시
</details>

<details>
<summary> JVM의 역할 </summary>

- JVM은 스택 기반으로 동작

- Java Byte Code를 OS에 맞게 해석해주는 역할

- 가비지컬렉션을 통해 자동적인 메모리 관리
</details>

<details>
<summary> Java의 컴파일 과정 <summary>

- 개발자가 확장자명이 .java인 자바 파일을 생성하여 build
- java compiler에 의해 확장자명 .class인 자바 바이트코드를 생성
- Class Loader를 통해 JVM 메모리 내로 로드
- 실행엔진을 통해 컴퓨터가 읽을 수 있는 기계어로 해석

</details>

<details>
<summary> Java에서 제공하는 원시 타입, 각각 몇 바이트? <summary>

- 정수형 byte(1), short(2), int(4), Long(8)
- 실수형 float(4), double(8)
- 문자형 char(2)
- 논리형 boolean(1)
</details>

<details>
<summary> 오버라이딩과 오버로딩 <summary>

- 오버라이딩은 상위 클래스의 메소드를 하위 클래스의 메소드에서 재정의하는것
  - toString, 상속
- 오버로딩은 같은 이름의 메소드를 매개변수의 타입과 갯수를 다르게하여 여러개 정의하는것
  - 생성자 오버로딩(매개변수 없는 경우, 모든 매개변수가 있는 경우)
</details>

<details>
<summary> 객체지향 프로그래밍에 대해 설명 <summary>

- 객체지향 프로그래밍은 현실세계에 존재하는 모든 사물을 객체로 보고, 프로그래밍 구현 시 프로그램에 필요한 객체를 파악하고 그 상태와 행위를 가진 객체를 만들어 각각 객체들의 역할이 무엇인지 정의하여 객체들 간의 상호작용을 통해 프로그램을 만드는 것
- 기능이 아닌 객체가 중심으로 누가 무엇을 할것인가를 정의하는 것입니다.
- 특징으로는 캡슐화, 상속, 다형성, 추상화 등이 있고 모듈을 재사용할 수 있다는 장점이 있어 확장 및 유지보수가 용이합니다.
</details>


<details>
<summary> try-with-resources <summary>

- try-catch-finally의 문제점을 보완하기 위해 나온 개념
- try() 안에 자원 객체를 전달하면 try 블록이 끝나고 자동으로 자원을 해제해주는 기능입니다.
- 따로 finally 문을 작성하지 않아도 됩니다.

</details>

<details>
<summary> 불변 객체가 무엇인지 설명하고 대표적인 Java의 예시 <summary>

- 불변 객체란 객체가 생성된 이후 내부의 상태가 변하지 않는 객체
- Java에서는 원시 타입의 경우 final 키워드를 사용해 불변객체를 만들 수 있고 참조 타입일 경우엔 추가적인 작업이 필요함
- 참조타입일 경우 배열을 예시로 들면 배열을 받아 copy해서 저장하고, getter를 clone으로 반환하여 불변 객체를 만들 수 있습니다.
- 리스트도 마찬가지로 내부를 복사하여 전달하는데 이를 방어적 복사라고 합니다.
- 불변객체는 Thread-safe하여 병렬 프로그래밍에 유용하며, 동기화롤 고려하지 않아도 됩니다.
  - Thread-safe 하다는 것은?
    - Thread는 프로그램의 독립적인 실행 흐름, 여러 작업을 동시에 처리하기 위해 사용
    - Thread-safe는 멀티쓰레드 프로그래밍 환경에서 사용되는 용어로 어떤 자원에 여러 쓰레드가 동시에 접근해도 프로그램 실행에 문제가 없는 상태를 의미합니다.
- 메소드 호출 시 파라미터 값이 변하지 않는다는 것을 보장할 수 있습니다
- 가비지 컬렉터가 스캔하는 객체의 수가 줄기때문에 가비지 컬렉션 성능을 높일 수 있습니다. 
</details>

<details>
<summary> 추상 클래스와 인터페이스는 각각 무엇이고 그 차이는 무엇인가? <summary>

- 추상 클래스는 클래스 내에 메소드에 선언부만 있고 구현부가 없는 추상메소드가 하나 이상 포함하는 클래스를 추상 클래스라고 합니다.
- 인터페이스는 모든 메소드가 추상 메소드로 이루어진것
### 공통점
- new 연산자로 인스턴스 생성 불가
- 사용을 위해 하위 클래스에서 확장 / 구현
### 차이점
- 추상 클래스는 클래스 내에 변수, 구현부가 있는 메소드가 존재할 수 있지만 인터페이스는 불가능
- 추상클래스는 다중상속이 불가능, 인터페이스는 가능
</details>

<details>
<summary> 가비지 컬렉션 <summary>

- Java의 메모리 구조 중 Heap 메모리 영역에 동적 할당되었으나 더이상 참조되지 않는 대상을 탐지하여 메모리에서 해제하는 JVM의 기능
  - 왜 Heap 영역인가? -> 객체가 새로 생성되면 Heap 영역에 되기때문
  - 더이상 참조되지않는다는 것 객체가 null 이 되는 것
- 개발자가 코드로 호출할 필요 없이 JVM이 백그라운드에서 자동적으로 수행
</details>

<details>
<summary> 객체지향의 설계원칙 <summary>

객체 지향의 설계 원칙은 SOLID 라고 함
### S
SRP 단일 책임의 원칙
- 하나의 클래스는 하나의 책임을 가져야하며, 변경 또한 하나의 이유를 가져야함
### O
OCP 개방 폐쇄의 원칙
- 클래스는 확장에는 개방적이고 변경에는 폐쇄적이여야함
### L
LSP 리스코프 치환의 원칙
- 하위 타입의 객체는 상위 타입의 객체에서 가능한 행위를 수행할 수 있어야함
- 즉 하위 타입은 상위 타입으로 대체될 수 있어야함
### I
ISP 인터페이스 분리의 원칙
- 인터페이스는 최소한의 기능을 가져야 한다는 원칙
- SRP와 동일한 개념으로 SRP는 클래스 ISP는 인터페이스가 그 대상이 된다는 것
### D
DIP 의존관계 역전의 원칙
- 구현클래스에 의존하지말고 보다 추상적인 클래스 (인터페이스)에 의존해야한다는 것

</details>

<details>
<summary> 자바의 메모리 영역 <summary> 

- 자바의 메모리영역은 크게 모든 스레드가 공유해서 사용하는 메소드영역, 힙영역
- 스레드 별로 하나씩 생성되는 스택영역, PC 레지스터, 네이티브 메서드 스택으로 구분됨
  - 메소드 영역은 static 변수, final 클래스 등이 생성되는 영역
  - 힙 영역 new 키워드로 생성된 객체와 배열 등이 생성되는 영역
    - GC가 사용하지않는 인스턴스를 감지해 메모를 관리하는 영역
  - 스택영역은 지역 변수, 파라미터, 리턴 값 등이 생성되는 영역
  - PC 레지스터는 현재 스레드가 실행되는 부분의 주소와 명령을 저장하고 있는 영역
  - 네이티브 메서드 스택
    - 자바 이외의 언어로 작성된 네이티브 코드를 실행할 때 사용되는 메모리 영역

</details>

<details>
<summary> 람다식 <summary>
함수형 프로그래밍 기법, 메서드를 하나의 식으로 표현하는 방식

### 람다식의 장점
코드의 간결성과 가독성을 높일 수 있음

### 람다식 구현 방법
- 매개변수 -> 구현부로 이용하여 사용
- 구현부가 단일 실행문이면 {} 실행 가능
- 단일문이 return문만이면 괄호를 생략 가능

### 익명함수란
- 이름이 붙지 않고 프로그램에서 일시적으로 한번만 사용되고 버려지는 객체
- 재사용성이 없음
- 일시적으로 한번만 사용되어야 하는 객체의 경우 사용

</details>

<details>
<summary> 제네릭 <summary>
클래스나 메서드에서 사용될 데이터 타입을 미리 지정하지 않고 실행 시점에 결정할 수 있도록 하는 기술

- List가 그 예시, List에 담기는 객체를 그 때 그 때 지정해서 사용하는 것
- <> 괄호로 사용할 수 있음
- 제네릭은 괄호 내부에 식별자 기호를 지정해서 사용할 수 있는데 이 때 식별자를 타입 매개변수라고 하며 T로 사용함
### 타입 매개변수
- 제네릭을 이용한 클래스나 메소드 설계 시 사용
- jdk 1.7 버전 이후부터 new 생성자 부분의 제네릭 타입 생략 가능 -> 제네릭 나름 타입 추론을 하여 생략된 곳을 넣어주기 때문
- 타입 파라미터에 할당 가능한 타입은 Reference 타입 뿐
- Wrapper 클래스 (Integer, Double 등)이 이때 사용됨
- 제네릭 내부에 타입은 여러개 지정할 수 있음
### 제네릭 사용 이유와 이점
- 컴파일 시 타입 검사를 통해 예외 방지
- 불필요한 캐스팅을 없애 성능 향상

</details>

<details>
<summary> 예외처리 <summary>
  
  - 예외란 실행 도중 발생한 비정상적인 상황을 말하며 예외 처리를 통해 프로그램이 비 정상적으로 종료되지 않도록 처리 가능
  - try-catch-finally 구문을 사용하거나 throws 예외 타입을 메서드 선언부에 추가
  - ExceptionHandler를 통해 전역적으로 처리하는 방법 등이 있음

</details>

<details>
<summary> Stream <summary>


</details>
<details>
<summary> JRE와 JDK의 차이 <summary>

#### JRE
- java runtime environment 로 자바 프로그램을 실행시키는 환경
- read only

#### JDK
- java development kit 로 자바를 활용해서 개발하는데 사용, jdk는 jre를 포함하고 있다
- write, read only
</details>

<details>
<summary> Call by Value / Call by Reference <summary>
- 메소드의 매개변수 호출 방식
- Call by value는 값을 전달하는 것으로 a 메소드에서 보낸 값을 b에서 변경한다고 해도 a 메소드가 가지고 있던 본래의 값이 변화하지 않음
- Call by reference는 객체의 참조값, 주소를 전달하는 것으로 a 메소드에서 보낸 객체를 b 메소드에서 변경하면 a 메소드가 가지고 있던 본래의 값 또한 변경되는 것

</details>

## 웹
1. WAS와 WS의 차이

- WS는 Web Server의 약어로 클라이언트가 브라우저 주소창에 어떤 url을 입력하여 페이지를 요청하면 http 요청을 받아 들여 정적인 콘텐츠를 사용자에게 전달해주는 것으로 비즈니스 로직을 넣을 수 없음
    - Nginx, Apache 등이 예시 

- WAS는 Web Application Server의 약어로 클라이언트가 브라우저 주소창에 어떤 url을 입력하여 페이지를 요청하면 http 요청을 받아들여 동작함. 웹 서버가 할 수 있는 대부분의 기능 외에도 비즈니스 로직을 처리할 수 있어 사용자에게 동적인 콘텐츠 전달 가능
    - Tomcat, PHP, ASP 등

2. Spring Framework란?
스프링 프레임워크는 자바 개발을 편리하게 해주는 오픈소스 프레임워크

3. @RequestBody, @RequestParam, @ModelAttribute의 차이
