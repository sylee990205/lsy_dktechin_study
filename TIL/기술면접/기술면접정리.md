# Tech interview

## Java
<details>
<summary> Java의 특징 </summary>
Java는 객체지향 프로그래밍 언어로 기본 자료형을 제외한 모든 요소들이 객체로 표현됩니다.

- 객체 지향 개념의 특징인 캡슐화, 상속, 다형성이 잘 적용된 언어
- 장점
  - 자바는 자바 프로그램이 실행되는 동안 운영체제를 대신하는 자바 가상 머신 JVM 위에서 동작하기에 운영체제에 독립적이다
  - GabageCollector를 통한 자동적인 메모리 관리 가능
- 단점
  - JVM 위에서 동작한다는 것은 큰 장점이지만 JVM 위에서 동작하기때문에 다른 언어에 비교하여 실행 속도가 느리다는 단점이 있다
  - 다중 상속이나 타입에 엄격하며 제약이 많음

### 꼬리질문
- 방금 말씀하신 객체 지향 개념의 특징을 설명해주세요
  - 캡슐화
    - 객체 내부의 속성이나 행위를 외부에서 직접 접근할 수 없게 하는 것
    - private 멤버변수, getter/setter

  - 상속
    - 자식 클래스에서 부모 클래스로부터 부모의 모든 자원을 물려 받는 것을 의미
    - 상속을 통해 비효율적인 코드 중복을 피할 수 있고, 부모 클래스의 수정을 통해 자식 클래스 전체가 수정되기때문에 유지보수가 편리함
      ### 꼬리질문2
        - 자바는 다중상속을 지원하지않는데 그 이유는? 그리고 인터페이스는 지원하는데 왜 가능?
          - 다중상속의 경우 하나의 클래스가 여러 상위 클래스를 상속받는 것을 말하는데 여러 상위 클래스에 동일한 이름의 메소드가 있을 때 하위 클래스에서 어떤 메소드를 사용해야하는지 알 수 없는 문제가 발생해 자바에서는 다중상속을 지원하지않는것입니다.
          - 인터페이스는 구현체가 없기때문에 가능합니다.
    - 예시: Spring Data JPA를 사용하면 Repository에서 JpaRepository를 상속하여 우리가 직접 기능을 정의하지않아도 CRUD, Paging 등의 기능을 사용할 수 있는 것
  - 추상화
    - 클래스들의 공통적인 요소를 뽑아서 상위 클래스를 만들어내는 것
    - 즉, 공통적인 속성과 기능을 정의함으로써 코드의 중복을 줄이는 것
    - 자바에서의 예시로는 추상클래스와 인터페이스가 있음
    - 단점: 자바는 다중상속을 지원하지 않기 때문에 추상화를 사용하면 상속에 제한이 생길 수 있음, 자식 클래스에서 부모의 모든 기능을 사용하지 않아도 가지고 있어야한다는 것
  - 다형성
    - 하나의 객체나 메소드가 여러가지 다른 형태를 가질 수 있는 것
    - 오버라이딩과 오버로딩이 그 예시
</details>

<details>
<summary> JVM의 역할 </summary>

- JVM은 스택 기반으로 동작

- Java Byte Code를 OS에 맞게 해석해주는 역할

- 가비지컬렉션을 통해 자동적인 메모리 관리
</details>

<details>
<summary> Java의 컴파일 과정 </summary>

- 개발자가 확장자명이 .java인 자바 파일을 생성하여 build
- java compiler에 의해 확장자명 .class인 자바 바이트코드를 생성
- Class Loader를 통해 JVM 메모리 내로 로드
- 실행엔진을 통해 컴퓨터가 읽을 수 있는 기계어로 해석

</details>

<details>
<summary> Java에서 제공하는 원시 타입, 각각 몇 바이트? </summary>

- 정수형 byte(1), short(2), int(4), Long(8)
- 실수형 float(4), double(8)
- 문자형 char(2)
- 논리형 boolean(1)
</details>

<details>
<summary> 오버라이딩과 오버로딩 </summary>

- 오버라이딩은 상위 클래스의 메소드를 하위 클래스의 메소드에서 재정의하는것
  - toString, 상속
- 오버로딩은 같은 이름의 메소드를 매개변수의 타입과 갯수를 다르게하여 여러개 정의하는것
  - 생성자 오버로딩(매개변수 없는 경우, 모든 매개변수가 있는 경우)
</details>

<details>
<summary> 객체지향 프로그래밍에 대해 설명 </summary>

- 객체지향 프로그래밍은 현실세계에 존재하는 모든 사물을 객체로 보고, 프로그래밍 구현 시 프로그램에 필요한 객체를 파악하고 그 상태와 행위를 가진 객체를 만들어 각각 객체들의 역할이 무엇인지 정의하여 객체들 간의 상호작용을 통해 프로그램을 만드는 것
- 기능이 아닌 객체가 중심으로 누가 무엇을 할것인가를 정의하는 것입니다.
- 특징으로는 캡슐화, 상속, 다형성, 추상화 등이 있고 모듈을 재사용할 수 있다는 장점이 있어 확장 및 유지보수가 용이합니다.
</details>


<details>
<summary> try-with-resources </summary>

- try-catch-finally의 문제점을 보완하기 위해 나온 개념
- try() 안에 자원 객체를 전달하면 try 블록이 끝나고 자동으로 자원을 해제해주는 기능입니다.
- 따로 finally 문을 작성하지 않아도 됩니다.

</details>

<details>
<summary> 불변 객체가 무엇인지 설명하고 대표적인 Java의 예시 </summary>

- 불변 객체란 객체가 생성된 이후 내부의 상태가 변하지 않는 객체
- Java에서는 원시 타입의 경우 final 키워드를 사용해 불변객체를 만들 수 있고 참조 타입일 경우엔 추가적인 작업이 필요함
- 참조타입일 경우 배열을 예시로 들면 배열을 받아 copy해서 저장하고, getter를 clone으로 반환하여 불변 객체를 만들 수 있습니다.
- 리스트도 마찬가지로 내부를 복사하여 전달하는데 이를 방어적 복사라고 합니다.
- 불변객체는 Thread-safe하여 병렬 프로그래밍에 유용하며, 동기화롤 고려하지 않아도 됩니다.
  - Thread-safe 하다는 것은?
    - Thread는 프로그램의 독립적인 실행 흐름, 여러 작업을 동시에 처리하기 위해 사용
    - Thread-safe는 멀티쓰레드 프로그래밍 환경에서 사용되는 용어로 어떤 자원에 여러 쓰레드가 동시에 접근해도 프로그램 실행에 문제가 없는 상태를 의미합니다.
- 메소드 호출 시 파라미터 값이 변하지 않는다는 것을 보장할 수 있습니다
- 가비지 컬렉터가 스캔하는 객체의 수가 줄기때문에 가비지 컬렉션 성능을 높일 수 있습니다. 
</details>

<details>
<summary> Synchronized </summary>
멀티 쓰레드 환경에서 사용되는 키워드로 동기화

- 하나의 쓰레드에서 자원을 사용하고 있다면 다른 쓰레드에서 접근하는 것을 막아 교착 상태를 방지하는 키워드
- 데이터의 Thread-safe를 위해 자바에서 제공하는 키워드
- 변수와 메소드에 사용할 수 있음
- 키워드를 너무 많이 사용하면 동기화 요청이 너무 많아져 성능 저하가 될 수 있어 적절히 사용해야함


</details>

<details>
<summary> 추상 클래스와 인터페이스는 각각 무엇이고 그 차이는 무엇인가? </summary>

- 추상 클래스는 클래스 내에 메소드에 선언부만 있고 구현부가 없는 추상메소드가 하나 이상 포함하는 클래스를 추상 클래스라고 합니다.
- 인터페이스는 모든 메소드가 추상 메소드로 이루어진것
### 공통점
- new 연산자로 인스턴스 생성 불가
- 사용을 위해 하위 클래스에서 확장 / 구현
### 차이점
- 추상 클래스는 클래스 내에 변수, 구현부가 있는 메소드가 존재할 수 있지만 인터페이스는 불가능
- 추상클래스는 다중상속이 불가능, 인터페이스는 가능
</details>

<details>
<summary> 싱글톤 패턴 </summary>

- 단 하나의 인스턴스를 생성해 사용하는 디자인 패턴
- 인스턴스가 1개만 존재해야 한다는 것을 보장하고 싶은 경우와 동일한 인스턴스를 자주 생성해야하는 경우 메모리 낭비 방지를 위해 주로 사용

</details>

<details>
<summary> 가비지 컬렉션 </summary>

- Java의 메모리 구조 중 Heap 메모리 영역에 동적 할당되었으나 더이상 참조되지 않는 대상을 탐지하여 메모리에서 해제하는 JVM의 기능
  - 왜 Heap 영역인가? -> 객체가 새로 생성되면 Heap 영역에 되기때문
  - 더이상 참조되지않는다는 것 객체가 null 이 되는 것
- 개발자가 코드로 호출할 필요 없이 JVM이 백그라운드에서 자동적으로 수행
</details>

<details>
<summary> 객체지향의 설계원칙 </summary>

객체 지향의 설계 원칙은 SOLID 라고 함
### S
SRP 단일 책임의 원칙
- 하나의 클래스는 하나의 책임을 가져야하며, 변경 또한 하나의 이유를 가져야함
### O
OCP 개방 폐쇄의 원칙
- 클래스는 확장에는 개방적이고 변경에는 폐쇄적이여야함
### L
LSP 리스코프 치환의 원칙
- 하위 타입의 객체는 상위 타입의 객체에서 가능한 행위를 수행할 수 있어야함
- 즉 하위 타입은 상위 타입으로 대체될 수 있어야함
### I
ISP 인터페이스 분리의 원칙
- 인터페이스는 최소한의 기능을 가져야 한다는 원칙
- SRP와 동일한 개념으로 SRP는 클래스 ISP는 인터페이스가 그 대상이 된다는 것
### D
DIP 의존관계 역전의 원칙
- 구현클래스에 의존하지말고 보다 추상적인 클래스 (인터페이스)에 의존해야한다는 것

</details>

<details>
<summary> 자바의 메모리 영역 </summary> 

- 자바의 메모리영역은 크게 모든 스레드가 공유해서 사용하는 메소드영역, 힙영역
- 스레드 별로 하나씩 생성되는 스택영역, PC 레지스터, 네이티브 메서드 스택으로 구분됨
  - 메소드 영역은 static 변수, final 클래스 등이 생성되는 영역,  JVM이 동작해서 클래스가 로딩될 때 생성
  - 힙 영역 new 키워드로 생성된 객체와 배열 등이 생성되는 영역, 런타임시 할당
    - GC가 사용하지않는 인스턴스를 감지해 메모를 관리하는 영역
  - 스택영역은 지역 변수, 파라미터, 리턴 값 등이 생성되는 영역, 컴파일 타임 시 할당
  - PC 레지스터는 현재 스레드가 실행되는 부분의 주소와 명령을 저장하고 있는 영역
  - 네이티브 메서드 스택
    - 자바 이외의 언어로 작성된 네이티브 코드를 실행할 때 사용되는 메모리 영역

</details>

<details>
<summary> 람다식 </summary>
함수형 프로그래밍 기법, 메서드를 하나의 식으로 표현하는 방식

### 람다식의 장점
코드의 간결성과 가독성을 높일 수 있음

### 람다식 구현 방법
- 매개변수 -> 구현부로 이용하여 사용
- 구현부가 단일 실행문이면 {} 실행 가능
- 단일문이 return문만이면 괄호를 생략 가능

### 익명함수란
- 이름이 붙지 않고 프로그램에서 일시적으로 한번만 사용되고 버려지는 객체
- 재사용성이 없음
- 일시적으로 한번만 사용되어야 하는 객체의 경우 사용

</details>

<details>
<summary> 제네릭 </summary>
클래스나 메서드에서 사용될 데이터 타입을 미리 지정하지 않고 실행 시점에 결정할 수 있도록 하는 기술

- List가 그 예시, List에 담기는 객체를 그 때 그 때 지정해서 사용하는 것
- <> 괄호로 사용할 수 있음
- 제네릭은 괄호 내부에 식별자 기호를 지정해서 사용할 수 있는데 이 때 식별자를 타입 매개변수라고 하며 T로 사용함
### 타입 매개변수
- 제네릭을 이용한 클래스나 메소드 설계 시 사용
- jdk 1.7 버전 이후부터 new 생성자 부분의 제네릭 타입 생략 가능 -> 제네릭 나름 타입 추론을 하여 생략된 곳을 넣어주기 때문
- 타입 파라미터에 할당 가능한 타입은 Reference 타입 뿐
- Wrapper 클래스 (Integer, Double 등)이 이때 사용됨
- 제네릭 내부에 타입은 여러개 지정할 수 있음
### 제네릭 사용 이유와 이점
- 컴파일 시 타입 검사를 통해 예외 방지
- 불필요한 캐스팅을 없애 성능 향상

</details>

<details>
<summary> 예외처리 </summary>
  
  - 예외란 실행 도중 발생한 비정상적인 상황을 말하며 예외 처리를 통해 프로그램이 비 정상적으로 종료되지 않도록 처리 가능
  - try-catch-finally 구문을 사용하거나 throws 예외 타입을 메서드 선언부에 추가
  - ExceptionHandler를 통해 전역적으로 처리하는 방법 등이 있음

</details>

<details>
<summary> Error와 Exception의 차이 </summary>

- Error는 실행 중 일어날 수 있는 치명적인 오류로 컴파일 시점에서 체크할 수 없고, Error 발생 시 프로그램이 비정상 종료됨
- Exception은 Error보다는 비교적 경미한 오류이며, 예외처리를 통해 프로그램의 비정상 종료를 막을 수 있는 것


</details>

<details>
<summary> CheckedException과 UnCheckedException의 차이</summary>

- CheckException은 실행 전 예측 가능한 예외를 말하며 반드시 예외 처리를 해야함. 대표적으로 IOException이 있음
- UnCheckException은 실행 중 발생할 수 있는 예외를 말하며, 반드시 예외 처리를 해야하는 것은 아님. 대표적으로 NullPointerException이 있음
- RuntimeException을 상속하여 CustomException을 구현한다면 UnCheckedException이 됨


</details>

<details> 
<summary> 클래스와 객체의 차이 </summary>

- 클래스는 객체를 만들어내기 위한 설계도로 객체를 생성하는데에 사용됨
- 객체는 클래스를 기반으로 생성된 것
- 객체에 메모리가 할당되어 실제로 활용되는 실체를 인스턴스 (소프트웨어 내로 들어오면 인스턴스)

</details>

<details>
<summary> Wrapper Class란 무엇이며, Boxing 과 UnBoxing은 무엇인가 </summary>

- 자바의 원시타입, 기본 자료형 int, long 등을 객체로 표현한 것을 Wrapper Class라고 함
- 기본 자료형을 Wrapper class로 변환하는 것을 Boxing 그 반대를 UnBoxing 이라고 함
### 꼬리질문
Wrapper Class를 왜 사용하는가?
- 자바의 원시타입은 null 값이 들어갈 수 없음, 또한 이들은 참조 객체가 아니기 때문에 제네릭 구문 내에 사용할 수 없음
  - 제네릭의 < > 안에는 참조 객체만 들어갈 수 있기때문
- 그래서 이를 위해 Wrapper Class를 사용

</details>

<details>
<summary> Stream </summary>

- 자바8에서 추가된 람다를 활용할 수 있는 기술 중 하나
- 자바 8 이전에는 배열이나 컬렉션 인스턴스를 다루기 위해 for문이나 foreach 문을 돌면서 요소를 하나하나 꺼내서 다루었어야함
- 이를 람다식을 활용하여 보다 간결하게 표현할 수 있게 하는 것
- forEach, filter, map 등이 있음

</details>
<details>
<summary> JRE와 JDK의 차이 </summary>

#### JRE
- java runtime environment 로 자바 프로그램을 실행시키는 환경
- read only

#### JDK
- java development kit 로 자바를 활용해서 개발하는데 사용, jdk는 jre를 포함하고 있다
- write, read only
</details>

<details>
<summary> Call by Value / Call by Reference </summary>
- 메소드의 매개변수 호출 방식
- Call by value는 값을 전달하는 것으로 a 메소드에서 보낸 값을 b에서 변경한다고 해도 a 메소드가 가지고 있던 본래의 값이 변화하지 않음
- Call by reference는 객체의 참조값, 주소를 전달하는 것으로 a 메소드에서 보낸 객체를 b 메소드에서 변경하면 a 메소드가 가지고 있던 본래의 값 또한 변경되는 것

</details>

<details>
<summary> static </summary>
고정된 이라는 의미를 가짐, 메모리에 한번 할당되어 프로그램이 종료될 때 해제되는 것

- static 키워드는 변수나 메소드에 사용할 수 있습니다
- 클래스가 메모리에 올라갈 때 자동으로 생성되며 클래스 로딩이 끝나면 바로 사용 가능합니다. 즉 인스턴스 생성 없이 사용 가능하다는 것
- 메소드 영역에 생성되기 때문에 GC의 관리를 받지 않고 프로그램이 종료될 때까지 메모리에 값이 유지된 채로 존재하게 됨

#### 사용하는 이유
- 자주 변하지 않는 값이나 공통으로 사용되는 값인 공용 자원에 접근 시 매번 메모리에 로딩하고 값을 읽어들이는 것보다 비용을 줄이고 효율을 높일 수 있음
- 인스턴스 생성 없이 바로 사용 가능하여 프로그램 내에서 공통으로 사용되는 데이터들을 관리할 때 이용
  #### 예시
  - Controller 반환 시 ResponseEntity 를 사용했는데 그 때 body에 보낼 내용을 CommonResponse에 담아서 보냈다. 그 때 CommonResponse 클래스 내 toResponse라는 static 메소드를 사용하여 CommonResponse 인스턴스를 생성하지않고 바로 body에 담아 보낼 수 있었음
</details>

<details>
<summary> collection </summary>

- 배열 사용 시 크기가 고정적이고 데이터 삭제 시 해당 인덱스의 데이터가 비면서 메모리가 낭비되는 등의 문제점이 있었음
- 이러한 문제없이 다수의 데이터를 효율적으로 관리하고자 만들어진 자료구조들이 있는 라이브러리
- collection framework에는 List, Set, Map 등이 있음

### List
- 순서가 있는 데이터의 집합, 데이터의 중복을 허용, 대표적인 구현체로 ArrayList

### Set
- 순서가 없는 데이터의 집합, 데이터의 중복 비허용, 대표적인 구현체로 HashSet, 순서를 보장하기 위해 LinkedHastSet을 사용할 수 있음

### Map
- 키와 값이 한 쌍으로 이루어져 있고, 순서가 없는 데이터,  키를 기준으로 중복을 허용하지 않음, 대표적인 구현체로 HastMap이 있고 순서를 보장하기 위해 LinkedHastMap을 사용할 수 있음
 

</details>

<details>
<summary> optional </summary> 
  
- 개발 시 가장 흔히 발생하는 예외 중 하나인 NullPointerException을 피하기 위해 null 검사를 해야하는데 그에 대한 처리를 모두 작성하면 코드가 복잡해질 수 있음
- Optional 클래스를 사용해 NPE를 방지할 수 있도록 함
- null이 올 수 있는 값을 감싸는 Wrapper 클래스

- Optional.empty, 등등이 있지만 가장 많이 사용한 것은 Optional.get.orElseThrow, 예외가 발생할 때의 처리를 해줄 수 있음

- Optional을 너무 많이 사용하면 시스템 성능이 저하되기 때문에 결과가 null이 될 수 있으며 그로 인해 오류가 발생할 가능성이 매우 높을 때만 잘 사용해야함

</details>

<details>
<summary> new String과 ""(리터럴 문자열)의 차이 </summary>

- new String()은 new 키워드로 새로운 객체를 생성하기때문에 메모리 Heap영역에 저장됨
- 리터럴 문자열은 Heap 안에 있는 String Pool 영역에 저장됨

</details>

<details>
<summary> String, StringBuffer, StringBuilder </summary>

셋 모두 문자열을 표현하는 객체 타입
- String은 불변 객체이고, StringBuffer와 StringBuilder는 가변의 속성을 가짐
- StringBuffer는 동기화를 지원하여 멀티 쓰레드 환경에서 주로 사용하며
- String Builder는 동기화를 지원하지 않아 싱글 쓰레드 환경에서 주로 사용

#### String은 왜 불변객체?
- String 객체들은 Heap의 String Pool 이라는 공간에 저장되는데 참조하려는 문자열이 String Pool에 존재하는 경우 새로 생성하지 않고 Pool 내의 객체를 사용함

</details>

<details>
<summary> 직렬화 </summary>
 </details>


<details>
<summary> 리플렉션 </summary>
 </details>

## 웹
<details>
<summary> WAS와 WS의 차이 </summary>
- WS는 Web Server의 약어로 클라이언트가 브라우저 주소창에 어떤 url을 입력하여 페이지를 요청하면 http 요청을 받아 들여 정적인 콘텐츠를 사용자에게 전달해주는 것으로 비즈니스 로직을 넣을 수 없음
    - Nginx, Apache 등이 예시 

- WAS는 Web Application Server의 약어로 클라이언트가 브라우저 주소창에 어떤 url을 입력하여 페이지를 요청하면 http 요청을 받아들여 동작함. 웹 서버가 할 수 있는 대부분의 기능 외에도 비즈니스 로직을 처리할 수 있어 사용자에게 동적인 콘텐츠 전달 가능
    - Tomcat, PHP, ASP 등
  
</details>

<details>
<summary> Spring Framework란? </summary>

### Framework란
- 특정 형태의 소프트웨어 문제를 해결하기 위해 상호 협력하는 클래스 프레임과 인터페이스 프레임의 집합
- 개발 시간을 줄일 수 있고 오류로부터 자유로울 수 있다는 장점
- 프레임워크는 개발자의 자유를 제한하기 위한 것으로 프레임워크에 의존하면 개발 능력이 떨어질 수 있음

### Spring Framework란?
- 스프링 프레임워크는 자바 개발을 편리하게 해주는 오픈소스 경량급 프레임워크

</details>

<details>
<summary> Spring의 특징</summary>

- 스프링은 경량 컨테이너로서 자바 객체의 생성, 소멸과 같은 라이프사이클을 관리하며 스프링으로부터 필요한 객체를 얻어올 수 있음
- 스프링의 특징으로는 IoC, DI, AOP가 있음
### IoC
IoC는 제어의 역전, 컨트롤의 제어권이 사용자가 아닌 프레임워크에 있어서 필요에 따라 스프링에서 사용자의 코드를 호출한다는 것, 예시로 @Controller나 @Service 어노테이션을 통해 생성한 bean 객체의 라이프사이클 관리를 개발자가 아닌 스프링 프레임워크가 관리하게끔 함

### DI
DI는 의존성 주입의 약자로 사용할 객체를 직접 생성하지 않고 외부로부터 주입받아 사용하는 것. 이를 통해 객체간의 결합도를 줄이고 코드 재사용성을 높일 수 있음

### AOP
AOP는 관점지향프로그래밍의 약자로 핵심 비즈니스 로직에서 로깅과 같은 공통 관심사항을 분리하여 모듈화하는 것을 의미함, 중복 코드를 제거하고 재활용성을 극대화할 수 있음

</details>

<details>
<summary> Spring과 Spring Boot의 차이 </summary>

- Spring은 Java 기반 오픈 소스 프레임워크이며 대표적인 특징으로 DI, IoC, AOP가 있음
- Spring Boot는 Spring Framework를 사용하기 위한 설정의 많은 부분을 자동화한 프레임워크
  - SpringBootApplication이라는 어노테이션을 사용해 외부 라이브러리, 내장 톰캣 서버를 사용할 수 있는 것이 예시

</details>

<details>

<summary> Bean </summary>

- 스프링 컨테이너에 객체를 생성하면 객체끼리 의존성을 주입할 수 있는데, 이렇게 생성한 객체를 빈 이라고함
- @Component 어노테이션을 클래스 상단에 붙이면 해당 클래스들은 스프링 컨테이너에의해 자동으로 생성되어 스프링 빈으로 등록
- @Configuration 어노테이션을 클래스 선언부에 추가하여 설정 클래스를 만들고, 특정 탕비을 리턴하는 메소드를 만들어 @Bean을 붙이면 빈 객체가 생성됨
- 등록된 빈 객체들은 @Autowired나 @RequiredArgsConstructor를 통해 사용할 수 있음

</details>



<details>
<summary> Spring MVC 에 대하여</summary>

### Spring MVC란?
- MVC는 Model, View, Controller의 약자로 각 계층별 기능을 구분하는데 중점을 둔 디자인 패턴
- Model은 데이터 관리 및 비즈니스 로직을 처리하는 부분 (DTO, Service)
- View는 비즈니스 로직의 처리 결과를 통해 UI가 표현되는 부분 (html, tymeleaf 등)
- Controller는 사용자의 요청을 처리하고 Model과 View를 중개하는 역할

### Spring MVC 동작 흐름
1. 클라이언트가 URL을 통해 요청을 전송
2. DispatcherServlet이 핸들러 매핑을 통해 해당 요청이 어느 컨트롤러에게 온 요청인지 찾음
3. DispatcherServlet이 핸들러 어뎁터에게 요청의 전달을 맡김
4. 핸들러 어뎁터가 해당 컨트롤러로 요청을 전달
5. 컨트롤러가 비즈니스 로직 처리 후 반환할 뷰의 이름을 반환
6. DispatcherServlet은 뷰 리졸버를 통해 반환할 뷰를 찾음
7. DispatcherServlet이 컨트롤러에서 뷰에 전달할 데이터를 추가
8. 데이터가 추가된 뷰를 반환

#### MVC model1과 model2의 차이
- model1은 JSP 안에 HTML과 Java 코드를 전부 넣어 View와 Controller를 모두 jsp에서 구현하는 구조
- model1로만 처리하기엔 사이트가 방대해져 model2가 나왔음
- model2는 요청 받았을 때와 응답 할 때 처리할 기능을 나누는 것으로 MVC라고 말하는 것은 model2를 의미함

</details>

<details>
<summary> HTTP와 HTTP Stauts </summary>

- HTTP는 서버와 클라이언트간 통신을 위한 통신 규약이다. 사용자가 웹 서버에 http 요청을 전송하고 서버는 사용자에게 http 응답을 응답함
- 응답 시 상태 코드를 통해 요청의 성공 여부를 확인할 수 있음
- 대표적으로 성공을 의미하는 200번대, 클라이언트 오류를 의미하는 400번대, 서버 오류를 의미하는 500번대가 있음

</details>

<details>

<summary> Controller와 RestController의 차이 </summary>

- Spring MVC의 컨트롤러는 @Controller 어노테이션을 적용시키고 RESTful 서비스를 개발 시 @Controller에 @ResponseBody를 합친 RestController를 사용함
- Controller는 View를 반환하기 위해 컨트롤러에서 뷰의 이름을 반환하고 dispatcher servlet이 뷰 리졸버를 통해 뷰를 반환함
- RestController는 컨트롤러에서 View의 이름을 반환하는 것이 아닌 ResponseEntity에 데이터를 담아 JSON 형체로 반환함 
  - Controller 사용 후 return 타입에 @ResponseBody를 붙여 ResponseEntity를 반환하는 것과 흐름이 동일함

</details>


<details>

<summary> REST </summary>

- REST란 자원을 이름으로 구분하여 해당 자원의 상태를 주고 받는 모든 것을 의미
- 어떤 자원에 대해 CRUD 연산을 수행하기 위해 URI로 GET, POST 등의 HTTP 메소드를 통해 요청을 보내며, 요청을 위한 자원을 JSON과 같은 특정한 형태로 표현한 것

### 특징
1. Server-Client 구조
  - 자원이 있는 Server, 자원을 요청하는 Client로 나누어 Server가 API 제공, 비즈니스 로직 처리 및 저장을 책임지고 Client가 사용자 인증, 세션 등을 관리하는 것으로 서로의 역할을 구분시켜 의존성을 줄이는 것
2. Stateless (무상태성)
  - HTTP는 Stateless Protocol이기에 HTTP 프로토콜을 그대로 사용하는 REST 또한 무상태성을 가짐
  - 무상태하다는 것은 작업을 위한 상태 정보를 따로 저장하거나 관리하지 않는다는 것으로 클라이언트의 세션, 쿠키의 정보나 이전 api 요청에 대한 결과 등에 대한 영향 없이 api 요청을 처리하면 된다는 것
3. Cacheable (캐시 처리 기능)
  - 웹 표준 HTTP 프로토콜을 그대로 사용하므로 웹에서 사용하는 기존의 인프라를 그대로 활용할 수 있어 HTTP의 캐싱 기능을 적용할 수 있음
  - HTTP 프로토콜 표준에서 사용하는 Last-Modified Tag 또는 E-Tag를 이용해 캐싱을 구현할 수 있음
    - Last-Modified Tag : API 내용이 마지막으로 변경된 시간, 다음에 동일한 API를 요청할 경우 request header 에 if-modified-since 를 함께 보내 마지막 변경 시간을 체크하고 변경되지 않았을 경우 304 Status 코드를 주면서 활용 가능
    - E-Tag: Last-Modified와 방식은 거의 동일하나 시간 대신 Hash값을 사용함. 다음에 동일한 api를 요청할 경우 If-None-Match를 헤더에 추가하여 서버가 동일한 E-Tag를 가질 경우 304 return
    - 304 : Not-Modified
4. Layered System (계층 구조)
  - Client는 REST API 서버만 호출함
  - REST 서버는 다중 계층으로 구성될 수 있어 보안, 암호화 등의 계층을 추가하는 등 구조상 유연성을 가질 수 있고 PROXY 객체를 사용하는 등 중간매체를 사용해도 클라이언트가 알 수 없다는 것
5. Uniform Interface (인터페이스 일관성)
  - URI로 지정한 자원에 대한 요청을 통일되고, 한정적으로 수행하는 아키텍처 스타일
  - 아키텍처가 특정 언어나 기술에 종속되지 않도록 하는 것
6. Self-Descriptiveness (자체 표현)
  - 요청 메시지만 보고도 쉽게 이해할 수 있는 자체 구조로 표현되어 있음


</details>

<details>

<summary> REST API </summary>

- REST의 특징을 기반으로 API를 구현한 것을 REST API라고 함

- REST API 설계 시 가장 중요한 항목은 URI는 정보의 자원을 표현해야하며 자원에 대한 행위는 HTTP Method로 표현해야함. 단 URI에 Method는 포함해서는 안됨

### 설계 규칙
1. URI에 동사가 아닌 명사를 사용해야함
2. 슬래시(/)로 계층 관계를 표현
3. URI 마지막 문자로 슬래시를 포함하지 않음
4. 밑줄 대신 하이픈을 사용함
5. URI는 소문자로만 구성
6. 파일 확장자를 URI에 포함하지 않음
7. 응답 시 Http 응답 상태 코드를 활용하여 해당 요청에 대한 성공, 실패 여부를 알 수 있어야함

### RESTful API란?

- REST의 설계 규칙을 잘 지켜서 설계된 API를 Restful API라고 함
- API는 요청을 보내는 주소만으로 어떤 것을 요청하는지 파악이 가능해야함


</details>


1. @RequestBody, @RequestParam, @ModelAttribute의 차이

<details>
<summary> Spring Container </summary>
</details>

<details>
<summary> JPA </summary>
JPA는 Java Persistence API의 약어로 RDBMS와 객체의 패러다임 불일치 문제를 해결하기위해 만들어진 ORM 기술의 표준 API

### 이점
1. 생산성 증가 - 오직 객체지향적 접근만 고려하면 됨
2. 유지 보수 유리 - SQL과 JDBC를 모두 처리해야했던 과정을 JPA가 대신 하기에 수정 시 유지보수에 유리함
3. 성능 최적화 기회를 제공함

### 단점
1. 프로젝트의 규모가 크고 복잡하여 설계가 잘못된 경우, 속도 저하 및 일관성을 무너뜨릴 수 있음

### 꼬리질문1 - 패러다임 불일치 문제
OOP 객체에는 추상화, 상속, 다형성 같은 개념이 있지만 DB에는 없음. 서로가 지향하는 목적이 다르고 둘의 기능과 표현 방법 또한 다르기에 이것을 객체와 RDBMS의 패러다임 불일치 문제라고 함 

### 꼬리질문2 - ORM 기술이란?
Object Relational Mapping의 약어로 객체-관계 매핑 기술입니다. DB 데이터와 객체의 필드를 자동으로 매핑시킨다는 것으로, 객체를 통해 DB 데이터를 다룰 수 있음

### 꼬리질문3 - Spring Data JPA와 JPA의 차이
- Spring Data JPA는 JPA 기반 애플리케이션 개발을 보다 간편하게 만드는 라이브러리

### 꼬리질문4 - JPA와 MyBatis 비교
- MyBatis는 Mapper를 작성해야했으나 JPA는 Mapper가 없었고, 대부분 메소드 이름으로 해결할 수 있어 SQL 문을 직접 작성하지 않아도 해결이 가능해 좋았음


</details>

<details>
<summary> 영속성 컨텍스트란 </summary>
영속성 컨텍스트란 엔티티를 영구 저장하는 환경을 의미

### 생명주기
- 영속
  - 영속성 컨텍스트에 저장된 상태
- 준영속
  - 영속성 컨텍스트에 저장되었다가 분리된 상태
- 비영속
  - 영속성 컨텍스트와 전혀 관계 없는 상태
- 삭제
  - 삭제된 상태

### 이점
- 1차 캐시
  - 조회가 가능하며 1차 캐시에 없으면 DB에서 조회하여 1차 캐시로 가져옴
- 동일성 보장
  - == 비교가 가능
- 쓰기 지연
  - 트랜잭션 커밋 전까지 SQL을 바로 보내지 않고 모아서 보낼 수 있음
- 변경 감지 (더티 체킹)
  - 1차 캐시에 들어온 데이터의 최초 상태를 스냅샷으로 저장하고 커밋 시점에 비교하여 updateSQL을 생성
- 지연 로딩
  - 엔티티 안에서 엔티티를 불러올 때 사용 시점에 쿼리를 날려 가져올 수 있음

</details>

<details>
<summary> N+1 문제 </summary>

1번의 쿼리를 날렸을 때 의도하지 않은 N번의 쿼리가 추가적으로 실행되는 것
- 1대다 또는 다대1의 관계를 가진 엔티티를 조회할 때 발생
- JPA Repository로 find 시 실행하는 첫 쿼리에서 하위 엔티티까지 한 번에 가져오지 않고, 하위 데이터를 사용할 때 추가로 조회하기 때문에 발생


### 문제 해결 방법
1. fetch join
   - 미리 두 테이블을 Join하여 한번에 모든 데이터를 가져오는 방법
   - JPQL을 사용하여 두 테이블을 JOIN하는 쿼리를 직접 작성하는 것
2. Entity Graph
   - @EntityGraph 어노테이션을 사용하여 attributePaths에 같이 조회할 연관 엔티티명을 적어서 해결

#### fetch join vs Entity Graph
Fetch join은 inner join, Entity Graph는 outer join을 기본으로 함
- 기본적으로 outer join보다 inner join이 성능 최적화에 유리하기 때문에 fetch join이 더 많이 사용됨


</details>

<details>
<summary> fetch join </summary>
- 미리 두 테이블을 Join하여 한번에 모든 데이터를 가져오는 방법
- JPQL을 사용하여 두 테이블을 JOIN하는 쿼리를 직접 작성하는 것
- Inner join을 기본으로 함

### 단점
- 쿼리 한번에 모든 데이터를 가져오기 때문에 JPA가 제공하는 Paging API 사용 불가능(Pageable 사용 불가)
  - JPQL 작성 시 CountQuery를 직접 명시하고 이후 OOM 방지를 위해 batchSize를 설정하여 사용할 수 있음
    - bathcSize: 설정한 사이즈만큼 데이터를 끌어와서, 컬랙션이나, 프록시 객체를 한꺼번에 IN쿼리를 이용해서 조회하는 것, 100 ~ 1000이 적당
    - 데이터 사이즈를 확실하게 알 수 없으면 안좋은 방법일 수 있음
- 1:N 관계가 두 개 이상인 경우 사용 불가
  - 대상 컬렉션 객체를 Set으로 설정하면 가능
- 패치 조인 대상에게 별칭 부여 불가능
- 쿼리문을 직접 작성해야함

- fetch join 시 카테시안 곱 문제의 방지를 위해 JPQL 작성 시 DISTINCT를 추가하여 중복을 제거하거나 OneToMany의 필드 타입을 Set으로 선언하여 중복을 제거하는 방법을 사용할 수 있음

</details>

<details>
<summary> Entity Graph </summary>

- @EntityGraph 어노테이션을 사용하는 방법
- 어노테이션 속성 중 attributePaths에 같이 조회할 연관 엔티티명을 적고 ,로 여러 개를 한번에 할 수도 있음
- Fetch join과 동일하게 JPQL을 사용해 Query문을 작성하고 필요한 연관관계를 EntityGraph에 설정
- outer join이 기본적임

</details>

<details>
<summary> Fetch Join과 EntityGraph 의 카테시안 곱 </summary>

카테시안 곱: 두 테이블 사이 유효 join 조건을 적지 않았을 때 해당 테이블에 대한 모든 데이터를 전부 결합하여 테이블에 존재하는 행 갯수를 곱한만큼의 결과 값이 반환되는 것
- 카테시안 곱은 JPA 기능의 문제가 아니라 쿼리의 표현에서 발생하는 문제
- Join 명령 시 명확한 Join 규칙이 주어지지 않았을 때 발생

### 해결방법
- JPQL에 DISTINCT를 추가하여 중복 제거
- OneToMany의 필드 타입을 Set으로 선언하여 중복 제거
  - 순서 보장이 필요한 경우 LinkedHashSet을 사용

</details>

<details>
<summary> @Transactional </summary>

### 동작원리
- Transactional을 메소드 또는 클래스에 명시하면, AOP를 통해 Target 객체를 상속한 Proxy 객체가 생성되며 Proxy 객체의 메소드를 호출하면 Target 메소드 전 후로 트랜잭션 처리를 수행

</details>

## DB

<details>
<summary> 트랜잭션 </summary>

- 데이터베이스의 상태를 변화시키기 해서 수행하는 작업의 단위
- 트랜잭션은 작업의 완전성을 보장해주는 것
- 작업들을 모두 처리하거나 처리하지 못할 경우 이전 상태로 복구하여 작업의 일부만 적용되는 현상이 발생하지 않도록 만들어주는 것
- 하나의 트랜잭션은 Commit 되거나 Rollback 됨
  
### 트랜잭션의 특성 ACID
1. 원자성 (Atomicity)
   - 작업이 모두 반영되거나 모두 반영되지 않아야 함
2. 일관성 (Consistency)
   - 실행이 완료되면 언제나 일관성 있는 상태를 유지해야 함
3. 독립성 (Isolation)
   - 둘 이상의 트랜잭션이 동시에 실행될 경우 서로 연산에 끼어들 수 없어야함
4. 영속성 (Durability)
   - 완료된 결과는 영구적으로 반영되어야함

</details>

<details>
<summary> Indexing </summary>

- Index란 테이블을 처음부터 끝까지 검색하지 않고 인덱스를 검색하여 해당 자료의 테이블을 엑세스 하는 방법

- 인덱스는 항상 정렬된 상태를 유지하며 메모리 영역에 일종의 목차를 생성하는 것으로, 검색의 범위를 줄여 속도를 높일 수 있으나
- 새로운 값을 추가하거나 수정할 경우 쿼리문에 실행 속도가 느려진다는 단점이 있음

- 하나의 쇼핑몰에 여러가지 카테고리가 존재해 해당 카테고리의 상품을 조회 시 인덱스 기능을 활용한다면 큰 효율을 발휘하지만
- 인스타그램과 같은 소셜 서비스처럼 게시글의 작성, 수정, 삭제가 많은 서비스에서는 성능이 저하됨

</details>