# 230328 Java Day 17
## 목차
<!-- TOC -->

- [Java Day 17](#java-day-17)
    - [목차](#%EB%AA%A9%EC%B0%A8)
    - [멀티스레드 프로그래밍](#%EB%A9%80%ED%8B%B0%EC%8A%A4%EB%A0%88%EB%93%9C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)
        - [멀티 프로세스](#%EB%A9%80%ED%8B%B0-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4)
        - [멀티 스레드](#%EB%A9%80%ED%8B%B0-%EC%8A%A4%EB%A0%88%EB%93%9C)
            - [싱글 스레드 vs 멀티 스레드](#%EC%8B%B1%EA%B8%80-%EC%8A%A4%EB%A0%88%EB%93%9C-vs-%EB%A9%80%ED%8B%B0-%EC%8A%A4%EB%A0%88%EB%93%9C)
        - [멀티 프로세스 vs 멀티 스레드](#%EB%A9%80%ED%8B%B0-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-vs-%EB%A9%80%ED%8B%B0-%EC%8A%A4%EB%A0%88%EB%93%9C)
            - [멀티 스레드 프로그래밍을 결심하면](#%EB%A9%80%ED%8B%B0-%EC%8A%A4%EB%A0%88%EB%93%9C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%84-%EA%B2%B0%EC%8B%AC%ED%95%98%EB%A9%B4)
        - [스레드 생성](#%EC%8A%A4%EB%A0%88%EB%93%9C-%EC%83%9D%EC%84%B1)
        - [메인 스레드](#%EB%A9%94%EC%9D%B8-%EC%8A%A4%EB%A0%88%EB%93%9C)
        - [Start](#start)
        - [Stop](#stop)
        - [join](#join)
    - [스레드 상태](#%EC%8A%A4%EB%A0%88%EB%93%9C-%EC%83%81%ED%83%9C)
        - [실행 대기 상태](#%EC%8B%A4%ED%96%89-%EB%8C%80%EA%B8%B0-%EC%83%81%ED%83%9C)
        - [실행 상태](#%EC%8B%A4%ED%96%89-%EC%83%81%ED%83%9C)
        - [종료 상태](#%EC%A2%85%EB%A3%8C-%EC%83%81%ED%83%9C)
        - [일시 정지 상태](#%EC%9D%BC%EC%8B%9C-%EC%A0%95%EC%A7%80-%EC%83%81%ED%83%9C)
            - [일시정지로 보냄](#%EC%9D%BC%EC%8B%9C%EC%A0%95%EC%A7%80%EB%A1%9C-%EB%B3%B4%EB%83%84)
            - [일시정지에서 벗어남](#%EC%9D%BC%EC%8B%9C%EC%A0%95%EC%A7%80%EC%97%90%EC%84%9C-%EB%B2%97%EC%96%B4%EB%82%A8)
    - [데몬 스레드](#%EB%8D%B0%EB%AA%AC-%EC%8A%A4%EB%A0%88%EB%93%9C)
    - [동기화](#%EB%8F%99%EA%B8%B0%ED%99%94)
        - [동기화 메소드 및 블록 선언](#%EB%8F%99%EA%B8%B0%ED%99%94-%EB%A9%94%EC%86%8C%EB%93%9C-%EB%B0%8F-%EB%B8%94%EB%A1%9D-%EC%84%A0%EC%96%B8)
        - [Collection API 에서 동기화](#collection-api-%EC%97%90%EC%84%9C-%EB%8F%99%EA%B8%B0%ED%99%94)
    - [람다](#%EB%9E%8C%EB%8B%A4)
        - [함수형 인터페이스](#%ED%95%A8%EC%88%98%ED%98%95-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4)
            - [@FunctionalInterface](#functionalinterface)
        - [매개변수가 없는 람다식](#%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98%EA%B0%80-%EC%97%86%EB%8A%94-%EB%9E%8C%EB%8B%A4%EC%8B%9D)
        - [매개변수가 있는 람다식](#%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98%EA%B0%80-%EC%9E%88%EB%8A%94-%EB%9E%8C%EB%8B%A4%EC%8B%9D)
        - [리턴값이 있는 람다식](#%EB%A6%AC%ED%84%B4%EA%B0%92%EC%9D%B4-%EC%9E%88%EB%8A%94-%EB%9E%8C%EB%8B%A4%EC%8B%9D)
        - [메소드 참조](#%EB%A9%94%EC%86%8C%EB%93%9C-%EC%B0%B8%EC%A1%B0)
    - [오늘의 TIP](#%EC%98%A4%EB%8A%98%EC%9D%98-tip)
        - [Throws 상속](#throws-%EC%83%81%EC%86%8D)
        - [인터페이스를 상속하는 클래스 명 지을 때](#%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%A5%BC-%EC%83%81%EC%86%8D%ED%95%98%EB%8A%94-%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%AA%85-%EC%A7%80%EC%9D%84-%EB%95%8C)

<!-- /TOC -->
---
## 멀티스레드 프로그래밍
- 운영체제에 의존적인 프로그래밍
- 자바에서는 JVM이 운영체제를 대신함
- C와 비교했을 때 훨씬 쉽게 가능
- 상속 구문이 필수
  - 상속을 통해 구현을 좀 더 편하게
- 프로세스: 실행 중인 프로그램, 자원과 스레드로 구성
- 스레드: 프로세스 내에서 실제 작업을 수행
- 모든 프로세스는 **하나 이상의 스레드**를 가지고 있음
### 멀티 프로세스
- 멀티 프로세스 내에 프로세스들이 여러개 있음
- 그 프로세스 내에는 멀티 스레드나 싱글 스레드가 있음
  - 싱글 스레드: JVM이 메인 스레드를 작동 시킨 것
- 실행 파일을 시작하면 스레드가 시작됨
  - txt 파일 등은 실행 파일이 아님
  - exe 파일
### 멀티 스레드
- 멀티 스레드: 메인 스레드 외에 다른 스레드도 함께 작동 시킨 것
- 프로그램에서 병렬로 실행할 작업을 결정함
#### 싱글 스레드 vs 멀티 스레드
![](/TIL/image/2023-03-28-10-27-44.png)
- 싱글 스레드에서 2가지 기능을 구현한다고 했을 때
  - 사용자가 입력을 받아야하는 기능이 있다면 싱글 스레드는 해당 입력이 돌아올 때까지 그냥 기다려야함
- 멀티 스레드에서는 사용자 입력을 기다리는 동안 다른 스레드를 수행시키고 입력이 돌아오면 기존의 스레드를 다시 실행하는 방식으로 진행하면서 보다 시간의 효율이 증가함
### 멀티 프로세스 vs 멀티 스레드
![](/TIL/image/2023-03-28-09-35-21.png)
- 2 프로세스 1스레드 vs 1 프로세스 2 스레드
  - 멀티 스레드가 효율이 훨씬 좋음
- 멀티 프로세스에서 작동 중인 프로세스를 변경하는 것을 context switching이라함
  - context switching은 아무래도 비용이 발생
- 가급적이면 멀티 스레드를 사용하는 것이 좋음
  - 병렬 처리할 수 있는 일이면!
  - 다중처리는 멀티 스레드 효율이 좋음
#### 멀티 스레드 프로그래밍을 결심하면
- 어떤 기능을 구현할 것인지를 먼저 생각해야함
- 똑같은 기능을 여러개 띄운다면 스레드 클래스 1개만 만들면 됨
### 스레드 생성
```java
class MyThread extends Thread {
    public void run(){
        //작업 내용
        //Thread 클래스의 run을 오버라이딩
    }
}

class MyThread implements Runnable {
    public void run() {
        //작업 내용
        //Runnable 인터페이스의 추상메서드 run() 구현
    }
}

//어떤 방법으로 생성하던 Thread의 기능은 run() 메소드에 있음
```
### 메인 스레드
- 자기가 기동시킨 자식 스레드가 다 끝날때까지 기다렸다가 함께 종료됨
### Start()
- start가 콜스택을 하나 만들고 run을 호출함
- 스레드가 기동될 때 마다 기동되는 콜스택 하나가 무조건 생김
### Stop()
- 더 이상 사용되지않음
- 스레드 스스로 종료될 수 있게 구현
- 사용하던 자원을 반납하는 등의 작업을 수행한 후
### join()
- 메인 스레드가 join을 호출한 자식 스레드가 종료되기까지 기다렸다가 다음으로 넘어감
---
## 스레드 상태
### 실행 대기 상태
- 실행을 기다리고 있는 상태
### 실행 상태
- CPU 스케쥴링에 따라 CPU를 점유하고 run() 메소드를 실행.
- 스케줄링에 의해 다시 실행 대기 상태로 돌아갔다가 다른 스레드가 실행 상태 반복

### 종료 상태
- 실행 상태에서 run() 메소드가 종료되어 실행할 코드 없이 스레드의 실행을 멈춘 상태

### 일시 정지 상태
- 스레드가 실행할 수 없는 상태
- 스레디가 다시 실행 상태로 가기 위해서는 일시 정지 상태에서 실행 대기 상태로 가야함
#### 일시정지로 보냄
- Thread 클래스의 sleep() 메소드
  - 실행 중인 스레드를 일정 시간 멈추게 함
  - 매개값 단위는 밀리세컨드
- join()
  - 호출한 스레드는 일시 정지 상태
  - 실행 대기가 되려면 join() 메솧드를 가진 스레드가 종료되어야 함
- wait()
  - 동기화 블록 내에서 스레드를 일시 정지 상태로 만듬
#### 일시정지에서 벗어남
- interrupt()
  - 일시정지상태일 경우 InterruptedException을 발생시켜 실행 대기 상태 또는 종료 상태로 만듬
- notify(), notifyAll()
  - wait() 메소드로 인해 일시 정지 상태인 스레드를 실행 대기 상태로 만듬
---
## 데몬 스레드
- 일반 스레드의 작업을 돕는 보조적인 역햘을 수행하는 스레드
- 일반 스레드가 모두 종료되고 나면 데몬 스레드는 강제 종료
- 스레드 기등 전에 데몬화를 시켜야함
- 데몬화
```Java
Thread t = new Thread(new ThreadEx15())
t.setDeamon(true);
t.start();
```
---
## 동기화
- 어떤 스레드를 호출하고 있으면 다른 스레드를 호출할 수 없게 하는 것
- 멤버 변수에 붙일 수 없고 메소드나 블럭 단위로 사용 가능

### 동기화 메소드 및 블록 선언
- 인스턴스와 정적 메소드에 Synchoronized 키워드
- 생성
```java
public synchronized void synMethod() {
    //내용
}
```
- 같은 객체 내의 Synchronized가 부여된 모든 내용은 그 중 하나만 호출되어도 대기상태가 된다
- 동기화된 컬렉션

- 컬렉션 객체를 2개의 스레드가 접촉하여 사용한다고 할 때
- 하나의 스레드 접근 시 
### Collection API 에서 동기화
- 동기화를 사용하지않을 때 동기화를 지원하면 성능이 많이 떨어짐
- Collection API가 만들어졌을 때 기본으로 동기화를 지원하지 않겠다 설정
- ArrayList, StringBuffer 등 지원하지않음
- StringBulider 동기화 지원
- 만약 동기화를 사용하고 싶다면 Collections 객체를 활용
```java
List<T> synchronizedList(List<T> list)

Map<K,V> synchronizedMap(Map<K,V> m)

Set<T> synchronizsedSet(Set<T> s)
```
---
## 람다
- 함수형 프로그래밍
  - 함수를 정의하고 이 함수를 데이터 처리부로 보내 데이터를 처리하는 기법
- 람다식
  - 메소드 정의를 하나의 식으로 표현한 것
  - 자바에서 함수적 프로그래밍 지원 기법으로서 **익명 클래스 객체**가 됨
    - anonymous inner class와 상당히 밀접함
    - anonymous inner class는 클래스가 생성되지만 람다는 클래스가 생성되지않음
- 전달해야하는 객체가 인터페이스를 상속받는 객체일 때 오버라이딩을 해야하는 메소드가 1개라면 람다로 대체 가능
- 매개변수 지정 시 타입을 생략하고 변수명만 줘도 됨
  - 갯수만 맞으면 상관 없음
- return 키워드도 생략 가능
### 함수형 인터페이스
- 인터페이스가 단 하나의 추상 메소드를 가지는 것
#### @FunctionalInterface
- 인터페이스가 함수형 인페이스임을 보장하기 위해 사용하는 어노테이션
- 컴파일 과정에서 추상 메소드가 하나인지 검사해 정확한 함수형 인터페이스를 작성할 수 있게 도와주는 역할
### 매개변수가 없는 람다식
- 함수형 인터페이스의 추상 메소드에 매개변수가 없는 경우
- 실행문이 두 개 이상일 경우 중괄호 생략 불가 
- 하나일 경우에만 생략 가능
```java
( ) -> {
    실행문;
    실행문;
}

( ) -> 실행문;
```
### 매개변수가 있는 람다식
- 함수형 인터페이스의 추상 메소드에 매개변수가 있는 경우
- 매개변수 선언 시 타입 생략 가능
```java
(타입 매개변수, ...) -> {
    실행문;
    실행문;
}
//타입은 생략 가능
```
### 리턴값이 있는 람다식
- 함수형 인터페이스의 추상 메소드에 리턴 값이 있는 경우
- return 문 하나만 있을 경우에는 중괄호와 함께 return 키워드를 생략 가능
- 리턴값은 연산식 또는 리턴값이 있는 메소드의 호출식으로도 대체 가능
```java
(매개변수, ...) -> {
    실행문;
    return 값;
}

(매개변수, ...) -> 값;
```
### 메소드 참조
- 메소드를 참조해 매개변수의 정보 및 리턴 타입을 알아내 람다식에서 불필요한 매개변수를 제거

---
## 오늘의 TIP
### Throws 상속
- 만약 부모가 throws 절을 가지고 있으면 자식도 throws절이 가능하지만 반대의 경우 불가능
  - 이 경우 자식에서 예외처리를 하려면 반드시 try - catch
### 인터페이스를 상속하는 클래스 명 지을 때
- class명 뒤에 Impl을 붙여주는게 좋음
```java
interface Sample {
    int calc(int n);
}

class SampleImpl implements Sample {
    @Override
    public int calc(int n) {
        return n + 1;
    }
}
```
