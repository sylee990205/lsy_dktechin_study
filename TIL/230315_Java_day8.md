# 230315 Java Day 8
## 목차
<!-- TOC -->

- [Java Day 8](#java-day-8)
    - [목차](#%EB%AA%A9%EC%B0%A8)
    - [상속](#%EC%83%81%EC%86%8D)
        - [클래스간의 관계](#%ED%81%B4%EB%9E%98%EC%8A%A4%EA%B0%84%EC%9D%98-%EA%B4%80%EA%B3%84)
            - [상속관계](#%EC%83%81%EC%86%8D%EA%B4%80%EA%B3%84)
            - [포함관계](#%ED%8F%AC%ED%95%A8%EA%B4%80%EA%B3%84)
            - [상속 vs 포함](#%EC%83%81%EC%86%8D-vs-%ED%8F%AC%ED%95%A8)
        - [단일 상속](#%EB%8B%A8%EC%9D%BC-%EC%83%81%EC%86%8D)
    - [오버라이딩](#%EC%98%A4%EB%B2%84%EB%9D%BC%EC%9D%B4%EB%94%A9)
    - [다형성](#%EB%8B%A4%ED%98%95%EC%84%B1)
        - [참조변수의 형변환](#%EC%B0%B8%EC%A1%B0%EB%B3%80%EC%88%98%EC%9D%98-%ED%98%95%EB%B3%80%ED%99%98)
        - [비교 연산자 instanceof](#%EB%B9%84%EA%B5%90-%EC%97%B0%EC%82%B0%EC%9E%90-instanceof)
        - [매개변수의 다형성](#%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98%EC%9D%98-%EB%8B%A4%ED%98%95%EC%84%B1)
        - [배열](#%EB%B0%B0%EC%97%B4)
    - [제어자 modifier](#%EC%A0%9C%EC%96%B4%EC%9E%90-modifier)
        - [접근 제어자](#%EC%A0%91%EA%B7%BC-%EC%A0%9C%EC%96%B4%EC%9E%90)
        - [활용 제어자](#%ED%99%9C%EC%9A%A9-%EC%A0%9C%EC%96%B4%EC%9E%90)
    - [abstract](#abstract)
        - [abstract 메서드](#abstract-%EB%A9%94%EC%84%9C%EB%93%9C)
        - [abstract 클래스](#abstract-%ED%81%B4%EB%9E%98%EC%8A%A4)
    - [오늘의 Tip](#%EC%98%A4%EB%8A%98%EC%9D%98-tip)
        - [class 생성 시 주의](#class-%EC%83%9D%EC%84%B1-%EC%8B%9C-%EC%A3%BC%EC%9D%98)
        - [getClass.getName](#getclassgetname)
        - [Object Type](#object-type)
        - [getter&setter](#gettersetter)
        - [클래스다이어그램에서 이탤릭체](#%ED%81%B4%EB%9E%98%EC%8A%A4%EB%8B%A4%EC%9D%B4%EC%96%B4%EA%B7%B8%EB%9E%A8%EC%97%90%EC%84%9C-%EC%9D%B4%ED%83%A4%EB%A6%AD%EC%B2%B4)

<!-- /TOC -->
---
## 상속
### 클래스간의 관계
#### 상속관계
- 공통부분은 부모에서 관리
- 개별 부분은 자식에서 관리
- 부모이 변경하면 자식도 영향
- 자식의 변경 부모에 영향 없음
#### 포함관계
- 한 클래스의 멤버변수로 다른 클래스를 선언
  - 다른 클래스의 인스턴스를 생성한다는 것
- 작은 단위의 클래스를 먼저 만들고 이를 조합하여 하나의 커다란 클래스를 만듬
```java
class point {
    int x;
    int y;
}

class Circle {
    Point c = new Point(); // 포함 관계
    int r;
}
```
#### 상속 vs 포함
| 상속     | 포함        |
| ------ | --------- |
| is a   | has a     |
| ...은 ...이다 | ...은 ...을 가진다 |
- 새로이 만들어야하는 클래스의 관계를 is a와 has a로 비교했을때 더 자연스러운 관계를 사용하면 됨

### 단일 상속
- Java는 단일 상속만 허용함
- *다중 상속*
  - C++은 다중 상속을 지원함
  - 다중 상속은 무거움
- 만약 한 클래스에서 여러 클래스의 멤버를 가져오고자 할 때 좀 더 비중이 높은 클래스 하나만 상속
- 다른 멤버는 포함 관계로 사용해야함

---
## 오버라이딩
- final이 붙으면 오버라이딩 불가

---
## 다형성
> "여러 가지 형태를 가질 수 있는 능력"   
> "하나의 참조 변수로 여러 타입의 객체를 참조할 수 있는 것"
- 부모 유형의 변수, 부모의 객체 뿐 아니라 상속된 모든 자식의 객체를 참조할 수 있다
- 변수를 하나 만들어 사용할 때 하나의 변수를 다양하게 사용할 수 있다
  - 해당 클래스의 객체, 해당 클래스 자손의 객체는 대입할 수 있다
  - 어떤 클래스 유형의 객체다 -> 해당 클래스의 객체 외에도 자손의 객체도 사용할 수 있다.
- 자바에 다형성이 없었으면 코딩의 양이 엄청 증가했을것
```Java
// Date 클래스의 객체 == Date 클래스 유형의 변수
Date d1 = new Date();

// 부모 유형의 객체로 자식 유형의 객체를 참조할 수 있음
Object d2 = new Date();
```
> 어떤 클래스 유형의 변수를 선언했다면 해당 클래스만 사용할 수 있는것이 아니고 그 부모의 클래스도 사용할 수 있다
- 어떤 클래스 유형의 변수냐에 따라 달라지는 점
  - 내가 접근할 수 있는 멤버들의 사양이 정해짐
  - d2는 자손에서 추가된 멤버에 접근할 수 없음
  - d1은 Object에 있는 멤버에도 접근이 가능하고 d1에 있는 멤버에도 접근이 가능

### 참조변수의 형변환
- 서로 상속 관계에 있는 타입간의 형변환만 가능
- Up-catsting
  - 자식 타입에서 부모 타입으로 형변환하는 경우
  - 생략 가능
- Down-casting
  - 부모 타입에서 자식 타입으로 형변환
  - 생략 불가능
  - 만약 하려면 형변환 연산자를 사용해야함

### 비교 연산자 instanceof
- 어떤 타입인지 비교하는 연산자
- 참조변수가 참조하는 인스턴스의 실제 타입을 체크하는데 사용

### 매개변수의 다형성
- 참조형 매개변수는 메서드 호출 시, 자신과 같은 타입 또는 자식 타입의 인스턴스를 넘겨줄 수 있음
- 메소드에 매개 변수로 자식 타입을 주면 필요한 개수만큼의 buy 메소드를 만들어야함
- 다형성을 사용하여 부모 타입을 주면 하나의 메소드로 여러개를 사용할 수 있음
```java
class Product{

}

class Tv extends Product { }
class Computer extends Product { }

void buy(Tv t){
    // 이 경우 Tv외 다른 상품을 산다하면 해당 타입의 buy 메소드를 다시 만들어야함
}

void buy(Product p){
    // 부모타입인 Product를 매개변수로 주면 하나의 메소드로 여러개 가능
}

Product p1 = new Tv();
Product p2 = new Computer();
```

### 배열
- 조상 타입의 배열에 자손들의 객체를 담을 수 있음

---
## 제어자 (modifier)
- 크게 접근 제어자와 활용 제어자로 나뉨

### 접근 제어자
- 접근을 제어함
- public, protected, (default), private
  - default라는 제어자는 없음. 접근 제어자를 생략하는 경우를 말함.
- 클래스 앞에 올 수 있는 접근 제어자
  - public, (default)
- 멤버 변수, 메서드, 생성자 메서드에 올 수 있는 접근 제어자
  - 모두 가능
  - 사용하는 이유
    - 외부로부터 데이터를 보호하기 위해
    - 외부에 불필요한 부분을 감추기 위해

### 활용 제어자
- 활용 방법을 제어함
- **static, final, abstract**, native, transient, synchronized, volatile, strictfp 
- static
  - 정적, 고정
  - 멤버 변수, 메서드 정의 가능
  - static 블록 생성 가능
  - 메모리 영역 고정
  - 클래스가 로딩될 때 자동으로 사용 가능한 상태가 된다
  - 객체 생성 시 클래스 이름으로 접근 가능하다
- final
  - "마지막의", "변경할 수 없는"
  - 클래스 앞에 올 수 있음
    - 상속 못한다는 의미
  - 멤버 변수, 메서드, 지역(매개) 변수 가능
- abstract
  - "추상적인", "사실적이지 않은", **"미완성의"**
  - abstract 메서드
  - abstract 클래스
---
## abstract
### abstract 메서드
- 메서드의 헤더(리턴값, 이름, 매개변수 등)만 정하고 코드 블록을 생략한 메서드
- 미완성 메서드
- abstract 메서드를 1개 이상 정의한 클래스는 반드시 abstract 클래스로 정의해야 함
- 자손에 의해 반드시 오버라이딩 해야하는 메서드

### abstract 클래스
- 미완성 클래스
- 객체 생성 불가능
- 상속으로만 사용 가능
- 클래스 내에 0개 이상의 abstarct 메서드가 존재할 수 있음
  - 없을수도 있는거 O
- 공통으로 묶는 역할이 필요할 때 생성

---
## 오늘의 Tip
### class 생성 시 주의
- 하나의 자바 소스에는 하나의 클래스만 두기
- 소스명과 클래스명을 동일하게 적용하기

### getClass().getName()
- 실제 만들어진 객체가 무엇인지 확인하고 싶을 때 사용함
```java
static void pirntObjectInfo(Object o) {
		System.out.println("전달된 객체의 클래스명 : "+ o.getClass().getName());
	}
```
### Object Type
- 매개변수로 Object 타입을 사용한다는 것은 아무튼 객체를 전달하라는 의미이다.
- 이 변수에는 Object이라면 무엇이든 대입할 수 있다
  - JDK5부터 autoboxing이 지원되기에 객체 외 다른 타입의 데이터를 대입해도 자동으로 변경됨

### getter&setter
- 클래스 내의 멤버변수 값을 다루는 메소드들
- setter : 입력받은 매개변수 값을 멤버변수에 대입
- getter : 멤버변수 값을 리턴
- 가장 많이 사용되는 메소드 중 하나로 대부분의 경우 개발자가 직접 개발하지않음
- 이클립스 등의 개발툴의 자동완성 기능을 활용함
- 이클립스의 경우  
  - Source 메뉴에 Generate Getters and Setters를 통해 사용 가능  
![](./image/2023-03-15-14-41-37.png) 

### 클래스다이어그램에서 이탤릭체
- 클래스 다이어그램에서 클래스명이 *operate* 처럼 이탤릭체라면 abstract 타입으로 구현하라는 의미