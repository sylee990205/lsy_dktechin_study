# 230512_Spring_day11
## 목차
<!-- TOC -->

- [_Spring_day9](#_spring_day9)
    - [목차](#%EB%AA%A9%EC%B0%A8)
    - [AOP 정의](#aop-%EC%A0%95%EC%9D%98)
        - [AOP의 장점](#aop%EC%9D%98-%EC%9E%A5%EC%A0%90)
    - [AOP를 구현하는 세가지 방법](#aop%EB%A5%BC-%EA%B5%AC%ED%98%84%ED%95%98%EB%8A%94-%EC%84%B8%EA%B0%80%EC%A7%80-%EB%B0%A9%EB%B2%95)
        - [프록시 패턴](#%ED%94%84%EB%A1%9D%EC%8B%9C-%ED%8C%A8%ED%84%B4)
        - [프록시 패턴으로 구현 시](#%ED%94%84%EB%A1%9D%EC%8B%9C-%ED%8C%A8%ED%84%B4%EC%9C%BC%EB%A1%9C-%EA%B5%AC%ED%98%84-%EC%8B%9C)
    - [AOP 용어](#aop-%EC%9A%A9%EC%96%B4)
    - [@Aspect](#aspect)
    - [Advice](#advice)
        - [Advice에 관련된 5가지 애노테이션](#advice%EC%97%90-%EA%B4%80%EB%A0%A8%EB%90%9C-5%EA%B0%80%EC%A7%80-%EC%95%A0%EB%85%B8%ED%85%8C%EC%9D%B4%EC%85%98)
            - [정리](#%EC%A0%95%EB%A6%AC)
        - [애노테이션 동작 순서](#%EC%95%A0%EB%85%B8%ED%85%8C%EC%9D%B4%EC%85%98-%EB%8F%99%EC%9E%91-%EC%88%9C%EC%84%9C)
            - [@Order](#order)
    - [PointCut](#pointcut)
        - [종류](#%EC%A2%85%EB%A5%98)

<!-- /TOC -->
---
## AOP 정의
> 각각 용어의 의미가 뭔지 잘 익히는 것이 중요함
> 
관점 지향 프로그래밍 (Aspect-Oriented Programming)
- 관점 : 어떤 기능을 구현할 때 그 기능을 핵심 기능과 부가 기능으로 구분한 각각의 기능

핵심 기능 | 부가 기능
-------- | --------- 
비즈니스 로직이 처리하려는 목적 기능 | 여러 비즈니스 로직 사이에서 공통적이고 반복적으로 필요한 기능
회원 서비스, 커뮤니티 서비스, 상품 서비스 | 로깅, 보안, 트랜잭션 
- AOP는 어떤 기능을 구현할 때 하나의 관점으로 보며 그 관점을 기준으로 묶어서 개발하는 방식
  - **핵심 기능과 부가 기능을 나눠서 개발**하는 것
- 어느 시점에 어떤 부가 기능이 필요한지
![](/TIL/image/2023-05-12-09-46-14.png)
- 여러 비즈니스 로직에 반복되는 부가 기능을 하나의 공통 로직으로 처리하도록 모듈화하여 삽입하는 방식 AOP
- **AOP는 공통된 기능을 재사용하는 기법**
### AOP의 장점
- 공통 기능을 하나의 장소에서 관리하여 유지보수가 좋음
- 핵심 로직과 부가 기능의 명확한 분리로, 핵심 로직은 자신의 기능에만 집중
---

## AOP를 구현하는 세가지 방법
```
1. 컴파일 과정에 삽입 (컴파일 시점)
2. 바이트코드를 메모리에 로드하는 과정에서 삽입(LTW) (클래스 로딩 시점)
3. 프록시 패턴을 이용 (런타임 시점) < 가장 일반적인 방법
```
- 스프링은 프록시 패턴과 LTW를 지원
### 프록시 패턴
- 프록시 : 대리자
- A 클래스와 동일한 사양을 가진 클래스를 하나 만듬
  - 인터페이스를 상속한다면 같이 상속
- 대신하는 클래스를 하나 만들어 부가 기능을 만듬
- A가 수행될 때 대리자 A가 같이 수행되면서 부가 기능까지 함께 수행됨
### 프록시 패턴으로 구현 시
- 인터페이스 사용 유무에 따라서도 구현 방법이 다름
- 사용한다면 JDK Dynamic Proxy
- 아니라면 CGLib
- 지금은 CGLib로 통일됨
- Runtime 방식
- 실제 대상 코드는 그대로 유지
- 프록시를 통해 부가 기능이 적용
- 프록시는 메소드 오버라이딩 개념으로 동작하기에 메소드에만 적용 가능
- 스프링 AOP는 AspectJ 문법을 차용하고 프록시 방식의 AOP 제공

---

## AOP 용어
- JointPoint 
  - 프로그램이 수행되면서 처리되는 각각의 기능이 수행되는 시점
  - 스프링에서는 메소드 호출 시에서만 적용
- Pointcut
  - 여러 조인 포인트들 중 부가적인 기능을 가지고있는 advice가 수행되는 시점
  - pointcut은 advice를 어떤 joinPoint에 결합할 것인지를 결정하는 설정
- advice
  - 실질적인 부가 기능 로직을 정의하는 곳
- target
  - advice의 대상이 되는 객체
- aspect, advisor
  - advice와 pointcutd을 모듈화 한 것
- weaving
  - pointcut으로 결정한 타겟의 joinPoint에 advice를 적용하는 것
- AOP 프록시
  - AOP 기능을 구현하기 위해 만든 프록시 객체
![](/TIL/image/2023-05-12-16-49-57.png)
- 위 사진에서 `@Before` 어노테이션의 속성이 Pointcut
- 어노테이션이 붙어있는 메소드가 advice
- 그 둘을 합쳐 advisor, aspect
- target과 advice가 합쳐져 현재 실행중인 객체를 AOP 프록시라고 함
---
## `@Aspect`
- `@Aspect` 애노테이션을 사용해 Advisor를 쉽게 구현 가능
- xml로 디스크립터 파일을 따로 설정하지 않아도 됨
- 단 `org.springframework.boot:spring-boot-starter-aop` 의 의존성을 추가해야함
- Aspect 클래스를 선언하는 기능
---
## Advice
- 실질적으로 프록시에서 수행하게 되는 로직을 정의하게 되는 곳
### Advice에 관련된 5가지 애노테이션
- 종류에 따라 포인트컷에 지정된 대상 메소드에서 Advice가 실행되는 시점을 정할 수 있음
- 속성값으로 Pointcut 지정 가능
1. `@Around`
   - 다른 4가지 애노테이션을 모두 포함
   - 메소드 호출 전 후 작업 명시 가능
   - JoinPoint 실행 여부 선택 가능
     - 메소드의 매개변수로 `ProceedingJoinPoint`
     - pjp.proceed() 메소드로 target method를 호출
       - 이 때 에러처리 필요
   - 입력 값 및 반환 값 변경이나 예외 처리 조작 가능
   - 해당 애노테이션이 붙은 메소드의 return값은 Target 메소드의 리턴값 유무에 따라 다름
     - 있으면 Object 타입을 return
     - 없으면 void
   
2. `@Before`
   - 조인 포인트 실행 이전에 실행
   - 입력 값은 변경할 수 없지만 setter와 같은 수정자로 내부 값 수정 가능
3. `@AfterReturning`
   - 조인 포인트가 정상 완료 후 실행
     - target 메소드 수행 완료 후 실행
   - 반환 값 자체는 변경할 수 없지만 반환 값 내부 setter와 같은 수정자로 수정 가능
4. `@AfterThrowing`
   - 메소드 실행 중 예외가 발생되면 실행
   - 예외가 발생했을 때 그를 알리는 출력만 수행하는 것
   - 예외처리가 되는 것은 아님 
     - 예외처리는 Around annotation에서 가능
5. `@After`
   - 조인 포인트의 정상, 예외 동작과 무관하게 메소드 종료시 실행
#### 정리
- Around를 제외한 나머지 메소드들은 첫번째 인자값으로 JoinPoint
- Around 메소드는 ProceedingJoinPoint
### 애노테이션 동작 순서
![](/TIL/image/2023-05-12-12-24-18.png)
- 그림에서는 `@AfterThrowing`과 `@AfterReturning`을 각 3-4 순서로 작성하였으나 둘은 같이 출력되지않음
- 따라서 3-1, 3-2가 더 옳은 표현
#### `@Order`
- 애노테이션의 동작  순서는 정의 되어 있으나 같은 애노테이션에 대한 동작 순서는 보장되지 않음
- `@Order` 애노테이션을 지정하여 처리 순서 지정이 가능
- Advice 단위가 아닌 Advisor 단위로만 지정이 가능
---
## PointCut
- PointCut은 Advice가 적용될 위치를 선별하는 기능
- 스프링 AOP는 프록시 기반 -> 메소드만 적용 가능
- 어느 메소드에 적용할 것인지 명시하는 것
### 종류
- execution
  - 실질적으로 가장 많이 사용
  - execution(접근제어자 반환타입 선언타입 메서드이름(파라미터))
  - 접근제어자나 반환타입에 `*`를 대신 입력하여 모든 타입 허용
  - ..를 사용하여 파라미터 수가 상관 없다는 것을 표현 가능
  - 상위 타입을 명시하면 하위 타입에도 적용 가능
  - 반환 타입이나 파라미터 타입의 경우 정확해야만 매칭
    - target method가 String이면 * or String을 입력해야만 매칭
- within
  - 클래스 타입을 지정하는 것
  - 클래스 내의 모든 메소드가 매칭
  - excution에서 타입 부분만 사용하는 것
- bean
  - 스프링 빈의 이름으로 AOP 적용 여부 지정
  - 스프링에서만 사용할 수 있는 특별한 지시자